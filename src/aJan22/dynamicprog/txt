max sub array
stocks
robber3 (rob 1 and rob2)
paint house2 (paint house1)
paint fence :   TRICKY
----------

718:  Maximum length of repeated subarray
Input: A = [1,2,3,2,1], B = [3,2,1,4,7]
Output: 3
Explanation: The repeated subarray with maximum length is [3,2,1].
subarray start at i from A and j from B
if A[i]==B[i]
dp[i][j] = dp[i+1][j+1] + 1
---------

322: coin change
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
DP on amount( i is amount)
dp[i] = 1 + min (dp[i - C1], dp[i - C2],.... dp[i - Ck])
----------------

91. Decode Ways
Input: s = "226"
Output: 3
Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).

Following is the intuition behind the dp solution. (It can be easily developed by doing examples of up to dp[4])
At poistion i, we can simply add the new character to the end of the path taken so far or combine it  with the previous character at i-1
No. of paths after simply adding a new character  to the paths that ended at i-1 =  DP[i-1]
No. of paths after  combining the  new character  with prev character(are the paths that ended at i-2 ) =  DP[i-2]
therefore dp[i] = d[i-1] + dp[i-2]. but conditions apply (you can't always combine)

----------------------------
5. Longest Palindromic Substring
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.

mistake:  picked an index, using that center started expanding. Was thinking of a 1D DP. Coming up with a recurrance relation was difficult
solutuion:  2d  boolean DP. Base =   if i == j, dp[i][j] == true,
recurrence: dp[i][j] =  dp[i-1][j+1]  if a[i] == a[j].  keep track of max as j - i  and save the index of the max value
-----------------------------
1048. Longest String Chain *******  good probem cz it has sevaral dp soln.

1st Suboptimal dp Solution
sort asc word length
dp[i]   = dp[j] + 1  ( j is from 0 to i-1) if a[i] is a predecessor
Complexity :  O ( NlogN  + N^2L)=  o(N( logN + NL))  - This might be ineffiecient if N >>> L

2nd better dp solution
sort asc word length
for word i, delete one character at a time and get the predecessor length from a DP map
* Here the memoization happens in a map instead of DP array. The map stores predecessors with the lenght of the word chain formed so far
Complexity:  Why is bottom up  DP approach Time complexity:  O (N (logN + L^2)). instead of O (N (logN + L)).
Where did the extra L come from ?  It says L is for creating each predecessor.
The remove charAt(i) on stringBuilder incurrs a cost of L I guess.
-----------------------------







