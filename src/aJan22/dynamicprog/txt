max sub array
stocks
robber3 (rob 1 and rob2)
paint house2 (paint house1)
paint fence :   TRICKY
----------

718:  Maximum length of repeated subarray
Input: A = [1,2,3,2,1], B = [3,2,1,4,7]
Output: 3
Explanation: The repeated subarray with maximum length is [3,2,1].
subarray start at i from A and j from B
if A[i]==B[i]
dp[i][j] = dp[i+1][j+1] + 1
---------

322: coin change
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
DP on amount( i is amount)
dp[i] = 1 + min (dp[i - C1], dp[i - C2],.... dp[i - Ck])
----------------

91. Decode Ways
Input: s = "226"
Output: 3
Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).

Following is the intuition behind the dp solution. (It can be easily developed by doing examples of up to dp[4])
At poistion i, we can simply add the new character to the end of the path taken so far or combine it  with the previous character at i-1
No. of paths after simply adding a new character  to the paths that ended at i-1 =  DP[i-1]
No. of paths after  combining the  new character  with prev character(are the paths that ended at i-2 ) =  DP[i-2]
therefore dp[i] = d[i-1] + dp[i-2]. but conditions apply (you can't always combine)

----------------------------
5. Longest Palindromic Substring
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.

mistake:  picked an index, using that center started expanding. Was thinking of a 1D DP. Coming up with a recurrance relation was difficult
solutuion:  2d  boolean DP. Base =   if i == j, dp[i][j] == true,
recurrence: dp[i][j] =  dp[i-1][j+1]  if a[i] == a[j].  keep track of max as j - i  and save the index of the max value
-----------------------------
1048. Longest String Chain *******  good probem cz it has sevaral dp soln.

1st Suboptimal dp Solution
sort asc word length
dp[i]   = dp[j] + 1  ( j is from 0 to i-1) if a[i] is a predecessor
Complexity :  O ( NlogN  + N^2L)=  o(N( logN + NL))  - This might be ineffiecient if N >>> L

2nd better dp solution
sort asc word length
for word i, delete one character at a time and get the predecessor length from a DP map
* Here the memoization happens in a map instead of DP array. The map stores predecessors with the lenght of the word chain formed so far
Complexity:  Why is bottom up  DP approach Time complexity:  O (N (logN + L^2)). instead of O (N (logN + L)).
Where did the extra L come from ?  It says L is for creating each predecessor.
The remove charAt(i) on stringBuilder incurrs a cost of L I guess.
------------------------------------------------------------
Knapsack Problem
W = (1, 2, 3) V = (6, 10 , 12).  Capacity = 5

        1       2       3       4         5(c from 0 to N)
1       6       6       6       6         6

           (6, 10)  (6,6+10)  (6,6+10)  (6,6+10)
2       6     10       16      16        16

           (10, )
3       6    10   (16,16+0) (16,6+12)   (16,10+12)
(i from 0 to 3)       16       18        22



dp[i][c] =   max(dp[i-1][c], dp[i-1][c - W[i]]  + V[i])
--------------------------------------------------
983.  Min cost of tickets   1 day or 7 day or 30 passes with costs[i].  Minimize $$$
Input: days = [1,4,6,7,8,20], costs = [2,7,15]
Output: 11
Explanation: For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total, you spent $11 and covered all the days of your travel.

solution:
if not traveling on day i then dp[i] = dp[i-1]
if traveling on day i then dp[i] =  min ( 2+ dp[i-2],  7+ dp[i-7], 15 + dp[i-30])
--------------------------------------------------------------






